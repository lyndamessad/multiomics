<<<<<<< HEAD
---
title: "tp_multi-omics"
author: "Lynda"
date: "20/10/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Consignes

Vous avez jusqu'au 30 Octobre 2020 pour rendre le devoir. Vous devez nous
remettre un fichier Rmd qui contient les réponses à toutes les questions.
Vous inclurez également **toutes les commandes** qui vous ont permises de répondre
aux questions.

N'oubliez pas d'inclure le nom et le prénom de tous les membres de l'équipe.

Vous pouvez nous joindre aux adresses suivantes:

* Arnaud Droit: Arnaud.Droit@crchudequebec.ulaval.ca
* Antoine Bodein: Antoine.Bodein@crchudequebec.ulaval.ca
* Charles Joly Beauparlant: Charles.Joly-Beauparlant@crchudequebec.ulaval.ca

## Objectifs

Utiliser les méthodes vu en cours pour intégrer des données multi-omiques.
Une grande partie du TP est réalisé grâce à la suite d'outils `mixOmics`.
De l'aide est disponible sur leur site (http://mixomics.org/).


 -----------------------------------------------------------------------------------------------------------------------------------------------------------
# ===========================================================
#                           PARTIE I
# ===========================================================
## 0. Préparation

1. Chargez le package `mixOmics`
```{r}
library("mixOmics")

```

2. Téléchargez et importez les données (4 fichiers: `mirna.csv`, `mrna.csv`, `protein.csv`, `sample_group.csv`)

**Question 1:** Combien avez-vous d'échantillons ? de variables (mRNA, protéines, miRNA) ?

Lecture des fichier:
```{r}
miRNA <- read.csv(file = "mirna.csv", header = T, sep ="," ,row.names = 1)
dim(miRNA)

mRNA <- read.csv(file = "mrna.csv", header = T, sep =",", row.names = 1 )
dim(mRNA)

prot <- read.csv(file = "protein.csv", header = T, sep =",", row.names = 1 )
dim(prot)

sampl_group <- read.csv(file = "sample_group.csv", header = T, sep ="," ,row.names = 1)
dim(sampl_group)
```
a/ miRNA: on a  150 échantillons , 184 variables (miRNA).
b/ mRNA: on a  150 échantillons , 200 variables (genes)
c/ prot: on a  150 échantillons , 142 variables (protéines)
d/ sampl_group : on a  150 échantillons , 1 variable


3. Le coefficient de variation est défini comme le rapport entre l'écart-type $\sigma$ et la moyenne $\mu$ : $c_v = \frac{\sigma}{\mu}$
Construisez un fonction qui calcule le coefficient de variation à partir d'un vecteur.


```{r}
coef_var = function(vecteur) {

   return(sd(vecteur)/mean(vecteur))
}



```

4. A l'aide d'un histogramme `hist()` affichez la distribution de chacun des blocs.

Pour cela, on va utiliser la fonction apply() afin d'appliquer la fonction coef_var pour chaque colonne de nos différents tableaux de données
Dans la fonction, on met:
- le nom du tableau de données
- le nombre 1 pour que la fonction s'applique sur les lignes ou 2 pour les colonnes
- le nom de la fonction à appliquer

```{r}
vec_miRNA = apply(miRNA, 2, coef_var) 
vec_mRNA= apply(mRNA, 2, coef_var)
vec_prot = apply(prot, 2, coef_var)
```

```{r}
hist(vec_miRNA,col = "blue") 
hist(vec_mRNA, col = "green") 
hist(vec_prot, col = "red") 
```

**Question 2:** La distribution des coefficients de variation est-elle similaire dans les 3 blocs ?
Si oui, quel type de donnée possède le plus de variabilité ?

D'après les représentations des histogrammes, on peut constater que selon les blocs, la distribution n'est pas la même.
les données de miRNA et mRNA ont toutes les deux un maximum de données avec un coefficient de variation entre 0.5 et 1. 
Par contre, les données protéines ne suit pas le meme principe. 

a. Pour les miRNA, on a une abondance plus importante des coeffcients de variation qui entre 0.05 et 0.1. 
b. Pour les mRNA, les coeffcients de variation entre 0.05 et 0.1 sont les plus abondants.
c. Pour les protéines, les coeffcients de variation entre 0 et 50 sont les plus abondants. 
.
```{r}
var(vec_miRNA)
var(vec_mRNA)
var(vec_prot)
```
Ceci confirme donc que les données miRNA et mRNA ont une faible variabilité comparé aux protéines qui ont la plus grande variabilité.


5. Pour chacun des blocs, filtrez les données les plus variantes :|cv| >= 0.15

```{r}
miRNA_filtre = miRNA[,names(which(abs(apply(miRNA, 2, coef_var))>=0.15))]
mRNA_filtre = mRNA[,names(which(abs(apply(mRNA, 2, coef_var))>=0.15))]
prot_filtre = prot[,names(which(abs(apply(prot, 2, coef_var))>=0.15))]
```

**Question 3:**: Combien reste-il de gènes ? de protéines ? de miRNA ?
```{r}
dim(miRNA_filtre)
dim(mRNA_filtre)
dim(prot_filtre)
```

Aprés filtrage des |cv| > 0.15, on trouve:
  a. miRNA :avant filtrage: 184, aprés filtrage 82 miRNA.
  b. mRNA :  avant filtrage : 200, aprés filtrage 8174 genes
  c. proteines: avant filtrage : 142,aprés filtrage 8 142 protéines.
  
On conclu donc que pour les protéines toutes les variables on un |cv| > 0.15.


**Question 4:** Quel est le gène le plus variant ? La protéine associé à ce gène est-elle présente dans le jeu de donnée.
```{r}
gene_plus_variant = vec_mRNA[which(vec_mRNA==max(vec_mRNA))]
sprintf("gene plus variant est le :")  
gene_plus_variant
```
Le gene le plus variant est "PLCD4"

```{r}
prot_filtre[,"HPLCD4"]
```

**Question 5:** A l'aide des bases de donnée de votre choix répondez aux questions suivantes:

# * Quel est le rôle de ce gène ? 
 
https://www.uniprot.org/uniprot/Q9BRC7#function
https://www.genecards.org/cgi-bin/carddisp.pl?gene=PLCD4

Son rôle est de coder pour un membre de la classe delta des enzymes phospholipases C. Celles-ci possède un rôle important dans plusieurs processus cellulaires. Elles hydrolysent le phosphatidylinositol 4,5-bisphosphate en deux seconds messagers intracellulaires, l'inositol 1,4,5-trisphosphate et le diacylglycérol. 
D'après de nombreuses recherches, ce gène pourrait être impliqué dans le maladies cancéreuses 

# • Sur quel chromosome est-il localisé ?
Sur le chromosome 2

# • Quelle est la longueur en nucléotide de sa séquence ?
762 pb

# • Quelle est la longueur en acides aminés de la protéine associée (ou des isoformes) ?
 
Size: 762 amino acids

 -----------------------------------------------------------------------------------------------------------------------------------------------------------
# ===========================================================
#                         Partie II
# ===========================================================


## ------- 1. Single-omic: l'ACP avec `mixOmics` -------------------------------

**Question 6:** A quoi sert l'Analyse en Composante Principale ? Expliquez brievement sont fonctionnement ?

L’ analyse en composantes principales (ACP) , ou principal component analysis (PCA) en anglais, est une méthode statistique qui permet d’analyser et de visualiser un jeu de données a condition que celui-ci présente des variables quantitatives qui le decrive.

Cette méthode est beaucoup utilitée pour des données multivariées. Cependant, les données doivent etre normalisées pour éviter que le résultat ne soit fausser par le poids d'une variables tres abondante par rapport aux autres variables.


1. Réaliser l'ACP sur les données mRNA.
```{r}
library("tidyverse")
#library("timeOmics")
library("mixOmics")
```

```{r}
mRNA_pca = pca(mRNA_filtre, scale = TRUE,  ncomp = 20)
```


**Question 7:** Combien de composantes retenez-vous ? Justifiez / Illustrez
```{r}
mRNA_pca$cum.var
```

Si on fixe un seuil à 50% de représentation des données. On s'arrete à la 6eme dimension.
justification: 
-------------
Les composants de la pca représentent les données de façon decroissante. En effet, les données sont représenté pour la majorité 
par le CP1, puis la CP2 améliore la représentation ainsi de suite jusqu'à atteindre une représentation de 100% des données.

Dans notre PCA, le seuil de 50% est atteint au bout de la CP6 (6eme dimension). 
Un seuil de 70% est atteint au bout de la CP18.

Pour la suite du TP, on choisis dans un premier lieu le seuil de 50% de la représentation des données.
Si le résultat n'est pas satisfaisant, on passera alors à un seuil de 70% de la représentation des données.


2. Après avoir relancer l'ACP avec le bon nombre de composante, utiliser un graphique pour représenter les variables.

```{r}
# pour 50%  ----> dimension = 6
mRNA_pca = pca(mRNA_filtre, scale = TRUE, ncomp = 6)

plotIndiv(mRNA_pca, col = "blue", title = 'Representation graphique de la PCA (ncomp = 6)')

```


**Question 8:** Quelles sont les variables qui contribuent le plus à l'axe 1 ?
```{r}
spca.result <- spca(mRNA_filtre, ncomp = 1, center = TRUE, scale = TRUE
                    )
spca.result$rotation
#spca.result
selectVar(spca.result, comp = 1)$value #valeurs

selectVar(spca.result, comp = 1)$name #noms

dim1_var = selectVar(spca.result, comp = 1)$name[which((selectVar(spca.result, comp = 1)$value) > 0)]
dim1_var


```
On a 99 variables qui contribuent le plus à l'axe 1. 
Ceux qui contribuent le plus est le gene "ZNF552"(value.var: 0.1371904005), puis "C4orf34" (value.var :0.1371892255).
celui qui contribu le moin est le gene "MXI1"(value.var: 0.0001037394)


3. Avec un graphique, représenter les échantillons dans l'espace formé par les composantes. 
Les échantillons sont colorés en fonction du groupe. Affichez la légende et ajoutez un titre.
```{r}
plotIndiv(mRNA_pca, group = sampl_group$Y, legend = TRUE, title = 'PCA by Group', ellipse = TRUE, col = c("red", "blue", "darkgreen"))
```

4. La *sparse ACP* `spca()` implémente une étape de *feature selection*. En utilisant la documentation de la fonction et/ou l'aide disponible en ligne,  utilisez la `spca()` de manière a sélectionner 10 gènes sur la première composante et 5 gènes sur la seconde composante.
```{r}
spca.result <- spca(mRNA_filtre, ncomp = 2, center = TRUE, scale = TRUE, 
                    keepX = c(10, 5))
selectVar(spca.result, comp = 1)$value
selectVar(spca.result, comp = 2)$value

```


**Question 9:** Quelles sont les gènes que vous avez sélectionnés? *(une fonction est disponible)*

Pour la CP1, les 10 genes qui selectionnés sont: 
KDM4B, ZNF552, PREX1, TTC39A, STC2, LRIG1, C4orf34, MTL5, FUT8, SLC19A2	

Pour CP2, les 5 genes selectionnés  spnt:
APBB1IP, NCF4,	FLI1, C1orf162, CSF1R


## ------- 2. Projection on Latent Structures ----------------------------------

1. Réalisez une PLS `pls()` avec les données mRNA et protéines en incluant 3 composantes `(ncomp = 3)`.

**Question 10:** A quoi sert la régression PLS pour l'intégration multi-omique?

2. Affichez un *scatter plot* des échantillons en affichant uniquement les composantes 2 et 3.
Les échantillons doivent être coloriés par groupe. Ajoutez une légende et un titre.

3. Affichez un *arrow plot* en affichant uniquement les composantes 1 et 3.
Les flèches doivent être coloriés par groupe. Ajoutez une légende et un titre.

4. La *sparse PLS* `spls()` implémente une étape de *feature selection*. En utilisant la documentation de la fonction et/ou l'aide disponible en ligne,  utilisez la *sPLS* de manière a sélectionner (10 gènes, 9 protéines) sur la première composante, (5 gènes, 5 protéines) sur la seconde composante et (1 gène, 1 protéine) sur la troisième composante.

**Question 11:** Quels sont les variables sélectionnées sur la troisième composante.

5. Affichez un *CIM plot* à partir du modèle *sPLS*.

**Question 12:** Quels sont les gènes et les protéines les plus corrélés? Justifiez à partir de la matrice de corrélation calculée par `cim()`.

6. Toujours à partir du même modèle *sPLS*, affichez un *network plot* en affichant uniquement les les corrélations les plus forte $(\rho \pm 0.65)$.

**Question 13:** Combien de clusters / sous-graphes observés vous ?

## ------- 2. *multiblock* Projection on Latent Structures -------------------

1. Réalisez une multiblock PLS `pls()` avec les données mRNA, protéines et miRNA `(X = list(mrna, prot), Y = mirna)` en incluant 2 composantes `(ncomp = 2)`.

2. Comme la `spls()`, la `block.spls()` implémente une étape de *feature selection*. En utilisant la documentation de la fonction et/ou l'aide disponible en ligne,  utilisez la fonction de manière a sélectionner (10 gènes, 9 protéines, 7 miRNA) sur la première composante et (5 gènes, 4 protéines, 3 miRNA) sur la seconde composante.

**Question 14:** Quels sont les variables sélectionnées sur la première composante.

## ------- 3. Analyse supervisée : (s)PLS-DA -------------------

Le fichier `sample_groupe.csv` associe un groupe à chaque échantillon.

**Question 15:** Donnez la répartition des groupes.

1. Utilisez la `pls.da()` en utilisant les gènes (`X`) et le groupe (`Y`) avec 2 composantes.

2. Affichez le graphe des échantillons.

**Question 16:** Comparez ce graphe avec le graphe des échantillons obtenu avec l'ACP (1.3). Quel méthode permet d'obtenir de meilleurs clusters?

## ------- 4. Analyse supervisée : block-(s)PLS-DA -------------------

1. Réalisez une multiblock sPLS-DA `block.splsda()` avec les données mRNA, protéines, miRNA `(X = list(mrna, prot, mirna))` et le groupe en incluant 5 composantes `(ncomp = 5)`.

2. Utiliser la fonction `perf()` sur le modèle obtenu. 

**Question 17:** Quelle serait le nombre de composante minimal à inclure ?

3. Relancez le modèle avec 2 composantes et utilisez l'option `keepX` pour sélectionner 15 gènes, protéines et miRNA sur la première compoante et 10 gènes, protéines et miRNA sur la seconde composante.

4. Réalisez un *circos plot* avec le modèle obtenu en affichant les corrélations fortes $|\rho| > 0.5$. Ajoutez un titre.

 -----------------------------------------------------------------------------------------------------------------------------------------------------------
# =============================================================================
#                         Partie III
# =============================================================================


## 5. Mises en situation

Dans cette section, nous allons vous présenter deux designs expérimentaux et il
vous faudra déterminer quelle est l'approche analytique à privilégier pour
répondre aux questions demandées. Il s'agit d'intégrer à la fois l'informations
sur l'analyse bioinformatique en partant des données brutes mais également de
cibler les bonnes approches multiomiques.

1. Un de vos collègue s'intéresse aux effets de l'exposition à des polluants
   sur la santé des ours polaires. Pour ce faire, il a accès à des données
   transcriptomiques provenant d'une vingtaine de trios (un mère et sa portée
   de deux enfants) ainsi qu'à diverses mesures cliniques numériques pour tous
   les échantillons.

2. Vous travaillez sur un modèle murin et vous souhaitez comprendre les impacts
   d'un traitement sur le microbiote. Vous avez accès à des données de
   séquençage de type 16S ainsi qu'à des données de métabolomiques pour des
   souris traitées et pour des souris non-traitées. Vous pouvez prendre pour
   acquis que l'analyse primaire des données de métabolomiques a déjà été
   complétées et que vous avez déjà accès aux décomptes pour chaque molécules.
=======
---
title: "tp_multi-omics"
author: "Lynda"
date: "20/10/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Consignes

Vous avez jusqu'au 30 Octobre 2020 pour rendre le devoir. Vous devez nous
remettre un fichier Rmd qui contient les réponses à toutes les questions.
Vous inclurez également **toutes les commandes** qui vous ont permises de répondre
aux questions.

N'oubliez pas d'inclure le nom et le prénom de tous les membres de l'équipe.

Vous pouvez nous joindre aux adresses suivantes:

* Arnaud Droit: Arnaud.Droit@crchudequebec.ulaval.ca
* Antoine Bodein: Antoine.Bodein@crchudequebec.ulaval.ca
* Charles Joly Beauparlant: Charles.Joly-Beauparlant@crchudequebec.ulaval.ca

## Objectifs

Utiliser les méthodes vu en cours pour intégrer des données multi-omiques.
Une grande partie du TP est réalisé grâce à la suite d'outils `mixOmics`.
De l'aide est disponible sur leur site (http://mixomics.org/).


 -----------------------------------------------------------------------------------------------------------------------------------------------------------
# ===========================================================
#                           PARTIE I
# ===========================================================
## 0. Préparation

1. Chargez le package `mixOmics`
```{r}
if (!require("mixOmics")) install.packages("mixOmics")
#Note: rgl installation failed-- installed XQuartz for X11
#https://www.xquartz.org/
```

2. Téléchargez et importez les données (4 fichiers: `mirna.csv`, `mrna.csv`, `protein.csv`, `sample_group.csv`)

**Question 1:** Combien avez-vous d'échantillons ? de variables (mRNA, protéines, miRNA) ?

Lecture des fichier:
```{r}
miRNA <- read.csv(file = "mirna.csv", header = T, sep ="," ,row.names = 1)
dim(miRNA)

mRNA <- read.csv(file = "mrna.csv", header = T, sep =",", row.names = 1 )
dim(mRNA)

prot <- read.csv(file = "protein.csv", header = T, sep =",", row.names = 1 )
dim(prot)

sampl_group <- read.csv(file = "sample_group.csv", header = T, sep ="," ,row.names = 1)
dim(sampl_group)
```
a/ miRNA: on a  150 échantillons , 184 variables (miRNA).
b/ mRNA: on a  150 échantillons , 200 variables (genes)
c/ prot: on a  150 échantillons , 142 variables (protéines)
d/ sampl_group : on a  150 échantillons , 1 variable


3. Le coefficient de variation est défini comme le rapport entre l'écart-type $\sigma$ et la moyenne $\mu$ : $c_v = \frac{\sigma}{\mu}$
Construisez un fonction qui calcule le coefficient de variation à partir d'un vecteur.


```{r}
coef_var = function(vecteur) {

   return(sd(vecteur)/mean(vecteur))
}


```

4. A l'aide d'un histogramme `hist()` affichez la distribution de chacun des blocs.

Pour cela, on va utiliser la fonction apply() afin d'appliquer la fonction coef_var pour chaque colonne de nos différents tableaux de données
Dans la fonction, on met:
- le nom du tableau de données
- le nombre 1 pour que la fonction s'applique sur les lignes ou 2 pour les colonnes
- le nom de la fonction à appliquer

```{r}
vec_miRNA = apply(miRNA, 2, coef_var) 
vec_mRNA= apply(mRNA, 2, coef_var)
vec_prot = apply(prot, 2, coef_var)
```

```{r}
hist(vec_miRNA,col = "blue") 
hist(vec_mRNA, col = "green") 
hist(vec_prot, col = "red") 
```

**Question 2:** La distribution des coefficients de variation est-elle similaire dans les 3 blocs ?
Si oui, quel type de donnée possède le plus de variabilité ?

D'après les représentations des histogrammes, on peut constater que selon les blocs, la distribution n'est pas la même.
les données de miRNA et mRNA ont toutes les deux un maximum de données avec un coefficient de variation entre 0.5 et 1. 
Par contre, les données protéines ne suit pas le meme principe. 

a. Pour les miRNA, on a une abondance plus importante des coeffcients de variation qui entre 0.05 et 0.1. 
b. Pour les mRNA, les coeffcients de variation entre 0.05 et 0.1 sont les plus abondants.
c. Pour les protéines, les coeffcients de variation entre 0 et 50 sont les plus abondants. 
.
```{r}
var(vec_miRNA)
var(vec_mRNA)
var(vec_prot)
```
Ceci confirme donc que les données miRNA et mRNA ont une faible variabilité comparé aux protéines qui ont la plus grande variabilité.


5. Pour chacun des blocs, filtrez les données les plus variantes :|cv| >= 0.15

```{r}
miRNA_filtre = miRNA[,names(which(abs(apply(miRNA, 2, coef_var))>=0.15))]
mRNA_filtre = mRNA[,names(which(abs(apply(mRNA, 2, coef_var))>=0.15))]
prot_filtre = prot[,names(which(abs(apply(prot, 2, coef_var))>=0.15))]
```

**Question 3:**: Combien reste-il de gènes ? de protéines ? de miRNA ?
```{r}
dim(miRNA_filtre)
dim(mRNA_filtre)
dim(prot_filtre)
```

Aprés filtrage des |cv| > 0.15, on trouve:
  a. miRNA :avant filtrage: 184, aprés filtrage 82 miRNA.
  b. mRNA :  avant filtrage : 200, aprés filtrage 8174 genes
  c. proteines: avant filtrage : 142,aprés filtrage 8 142 protéines.
  
On conclu donc que pour les protéines toutes les variables on un |cv| > 0.15.


**Question 4:** Quel est le gène le plus variant ? La protéine associé à ce gène est-elle présente dans le jeu de donnée.
```{r}
gene_plus_variant = vec_mRNA[which(vec_mRNA==max(vec_mRNA))]
sprintf("gene plus variant est le :")  
gene_plus_variant
```
Le gene le plus variant est "PLCD4"

```{r}
prot_filtre[,"HPLCD4"]
```

**Question 5:** A l'aide des bases de donnée de votre choix répondez aux questions suivantes:

# * Quel est le rôle de ce gène ? 
 
https://www.uniprot.org/uniprot/Q9BRC7#function
https://www.genecards.org/cgi-bin/carddisp.pl?gene=PLCD4

Son rôle est de coder pour un membre de la classe delta des enzymes phospholipases C. Celles-ci possède un rôle important dans plusieurs processus cellulaires. Elles hydrolysent le phosphatidylinositol 4,5-bisphosphate en deux seconds messagers intracellulaires, l'inositol 1,4,5-trisphosphate et le diacylglycérol. 
D'après de nombreuses recherches, ce gène pourrait être impliqué dans le maladies cancéreuses 

# • Sur quel chromosome est-il localisé ?
Sur le chromosome 2

# • Quelle est la longueur en nucléotide de sa séquence ?
762 pb

# • Quelle est la longueur en acides aminés de la protéine associée (ou des isoformes) ?
 
Size: 762 amino acids

 -----------------------------------------------------------------------------------------------------------------------------------------------------------
# ===========================================================
#                         Partie II
# ===========================================================


## ------- 1. Single-omic: l'ACP avec `mixOmics` -------------------

**Question 6:** A quoi sert l'Analyse en Composante Principale ? Expliquez brievement sont fonctionnement ?

L’ analyse en composantes principales (ACP) , ou principal component analysis (PCA) en anglais, est une méthode statistique qui permet d’analyser et de visualiser un jeu de données a condition que celui-ci présente des variables quantitatives qui le decrive.

Cette méthode est beaucoup utilitée pour des données multivariées. Cependant, les données doivent etre normalisées pour éviter que le résultat ne soit fausser par le poids d'une variables tres abondante par rapport aux autres variables.


1. Réaliser l'ACP sur les données mRNA.
```{r}
#install.packages("FactoMineR")
#install.packages("factoextra")

#library("FactoMineR")
#library("factoextra")
library("tidyverse")
#library("timeOmics")
library(mixOmics)
```

```{r}
mRNA_pca = pca(mRNA_filtre, scale = TRUE)
mRNA_pca
#mRNA_pca$eig
```

**Question 7:** Combien de composantes retenez-vous ? Justifiez / Illustrez

Si on fixe le seuil d'explication des données à 70%, on s'arrete donc à la 19eme composante.
On regarde donc la 3eme colonne des eigenvalue qui correspond à cumulative.variance.percent.
il s'agit de la somme des pourcentages de variance  de chaque composant et des précédentes. 

Au bout de la 19eme composante, on atteint  une représentation de 70% des données. 

Si on fixe un seuil à 50%, avec le meme raisonnement on s'arrete à la 6eme dimension.

2. Après avoir relancer l'ACP avec le bon nombre de composante, utiliser un graphique pour représenter les variables.

```{r}
# pour 50%  ----> dimension = 6
mRNA_pca = pca(mRNA_filtre, scale = TRUE, ncomp = 6)

plot.PCA(mRNA_pca, axes=c(1, 2))

```


**Question 8:** Quelles sont les variables qui contribuent le plus à l'axe 1 ?
```{r}
#methode 1
var_dim1 = mRNA_pca$var$contrib[,1][which(mRNA_pca$var$contrib[,1] > 1)]
var_dim1
#methode 2
#B= spca(mRNA_filtre,  ncomp = 1)
#selectVar(B)
spca.result <- spca(mRNA_filtre, ncomp = 1, center = TRUE, scale = TRUE, 
                    keepX = 10)
#spca.result

selectVar(spca.result, comp = 1)$value


```

3. Avec un graphique, représenter les échantillons dans l'espace formé par les composantes. 
Les échantillons sont colorés en fonction du groupe. Affichez la légende et ajoutez un titre.
```{r}
plotIndiv(mRNA_pca, group = sampl_group$Y, legend = TRUE, title = 'PCA, ggplot')
```

4. La *sparse ACP* `spca()` implémente une étape de *feature selection*. En utilisant la documentation de la fonction et/ou l'aide disponible en ligne,  utilisez la `spca()` de manière a sélectionner 10 gènes sur la première composante et 5 gènes sur la seconde composante.
```{r}
spca.result <- spca(mRNA_filtre, ncomp = 2, center = TRUE, scale = TRUE, 
                    keepX = c(10, 5))
#spca.result

selectVar(spca.result, comp = 1)$value
selectVar(spca.result, comp = 2)$value
```

**Question 9:** Quelles sont les gènes que vous avez sélectionnés? *(une fonction est disponible)*


## ------- 2. Projection on Latent Structures -------------------

1. Réalisez une PLS `pls()` avec les données mRNA et protéines en incluant 3 composantes `(ncomp = 3)`.

**Question 10:** A quoi sert la régression PLS pour l'intégration multi-omique?

2. Affichez un *scatter plot* des échantillons en affichant uniquement les composantes 2 et 3.
Les échantillons doivent être coloriés par groupe. Ajoutez une légende et un titre.

3. Affichez un *arrow plot* en affichant uniquement les composantes 1 et 3.
Les flèches doivent être coloriés par groupe. Ajoutez une légende et un titre.

4. La *sparse PLS* `spls()` implémente une étape de *feature selection*. En utilisant la documentation de la fonction et/ou l'aide disponible en ligne,  utilisez la *sPLS* de manière a sélectionner (10 gènes, 9 protéines) sur la première composante, (5 gènes, 5 protéines) sur la seconde composante et (1 gène, 1 protéine) sur la troisième composante.

**Question 11:** Quels sont les variables sélectionnées sur la troisième composante.

5. Affichez un *CIM plot* à partir du modèle *sPLS*.

**Question 12:** Quels sont les gènes et les protéines les plus corrélés? Justifiez à partir de la matrice de corrélation calculée par `cim()`.

6. Toujours à partir du même modèle *sPLS*, affichez un *network plot* en affichant uniquement les les corrélations les plus forte $(\rho \pm 0.65)$.

**Question 13:** Combien de clusters / sous-graphes observés vous ?

## ------- 2. *multiblock* Projection on Latent Structures -------------------

1. Réalisez une multiblock PLS `pls()` avec les données mRNA, protéines et miRNA `(X = list(mrna, prot), Y = mirna)` en incluant 2 composantes `(ncomp = 2)`.

2. Comme la `spls()`, la `block.spls()` implémente une étape de *feature selection*. En utilisant la documentation de la fonction et/ou l'aide disponible en ligne,  utilisez la fonction de manière a sélectionner (10 gènes, 9 protéines, 7 miRNA) sur la première composante et (5 gènes, 4 protéines, 3 miRNA) sur la seconde composante.

**Question 14:** Quels sont les variables sélectionnées sur la première composante.

## ------- 3. Analyse supervisée : (s)PLS-DA -------------------

Le fichier `sample_groupe.csv` associe un groupe à chaque échantillon.

**Question 15:** Donnez la répartition des groupes.

1. Utilisez la `pls.da()` en utilisant les gènes (`X`) et le groupe (`Y`) avec 2 composantes.

2. Affichez le graphe des échantillons.

**Question 16:** Comparez ce graphe avec le graphe des échantillons obtenu avec l'ACP (1.3). Quel méthode permet d'obtenir de meilleurs clusters?

## ------- 4. Analyse supervisée : block-(s)PLS-DA -------------------

1. Réalisez une multiblock sPLS-DA `block.splsda()` avec les données mRNA, protéines, miRNA `(X = list(mrna, prot, mirna))` et le groupe en incluant 5 composantes `(ncomp = 5)`.

2. Utiliser la fonction `perf()` sur le modèle obtenu. 

**Question 17:** Quelle serait le nombre de composante minimal à inclure ?

3. Relancez le modèle avec 2 composantes et utilisez l'option `keepX` pour sélectionner 15 gènes, protéines et miRNA sur la première compoante et 10 gènes, protéines et miRNA sur la seconde composante.

4. Réalisez un *circos plot* avec le modèle obtenu en affichant les corrélations fortes $|\rho| > 0.5$. Ajoutez un titre.

 -----------------------------------------------------------------------------------------------------------------------------------------------------------
# ===========================================================
#                         Partie III
# ===========================================================


## 5. Mises en situation

Dans cette section, nous allons vous présenter deux designs expérimentaux et il
vous faudra déterminer quelle est l'approche analytique à privilégier pour
répondre aux questions demandées. Il s'agit d'intégrer à la fois l'informations
sur l'analyse bioinformatique en partant des données brutes mais également de
cibler les bonnes approches multiomiques.

1. Un de vos collègue s'intéresse aux effets de l'exposition à des polluants
   sur la santé des ours polaires. Pour ce faire, il a accès à des données
   transcriptomiques provenant d'une vingtaine de trios (un mère et sa portée
   de deux enfants) ainsi qu'à diverses mesures cliniques numériques pour tous
   les échantillons.

2. Vous travaillez sur un modèle murin et vous souhaitez comprendre les impacts
   d'un traitement sur le microbiote. Vous avez accès à des données de
   séquençage de type 16S ainsi qu'à des données de métabolomiques pour des
   souris traitées et pour des souris non-traitées. Vous pouvez prendre pour
   acquis que l'analyse primaire des données de métabolomiques a déjà été
   complétées et que vous avez déjà accès aux décomptes pour chaque molécules.
>>>>>>> c55be011e5730255bbe0fd48e8130302d86fb82b
